require 'CSProjFile.rb'

def build(*relative_path)
	File.join("src","build",relative_path)
end

task :default => [:compile, :test]
task :all => [:clean, :default]

task :clean do 
	rm_rf(build)
	rm_rf("src/NanoContainer.Tests/bin")
	rm_rf("src/TestComp/bin")
end

task :precompile do
	mkdir_p(build) unless File.exists?(build)
	def _lib(relative_path)
		File.join("lib",relative_path)
	end
	def _precomp(files)
		files.each {|f| cp(_lib(f), build) unless uptodate?(build(f), _lib(f))}
	end
	_precomp(%w(NUnit.Framework.dll PicoContainer.dll Castle.DynamicProxy.dll NMock.dll Boo.Lang.CodeDom.dll Boo.Lang.Parser.dll Boo.Lang.Compiler.dll Boo.Lang.dll))
end

task :compile => :precompile do
	def _compile(project)
		projFile = CSProjFile.new(File.new("src/#{project}/#{project}.csproj"))
		unless uptodate?("#{build(project)}.dll",projFile.files.collect {|f| "src/#{project}/#{f}" })
			cd "src/#{project}"
			sh projFile.create_csc("../build")
			cd "../.."
		end
	end
	%w(NanoContainer NanoContainer.Tests TestComp TestComp2 NotStartable).each {|project| _compile(project)}
end

task :pretest do
	def tcVsOutput(*relative_path)
		File.join("src","TestComp","bin","Debug",relative_path)
	end
	mkdir_p(tcVsOutput) unless File.exists?(tcVsOutput)
	tcdll = "TestComp.dll"
	cp(build(tcdll), tcVsOutput) unless uptodate?(tcVsOutput(tcdll), build(tcdll))
	def nanoVsOutput(*relative_path)
		File.join("src","NanoContainer.Tests","bin","Debug",relative_path)
	end
	mkdir_p(nanoVsOutput) unless File.exists?(nanoVsOutput)
	def _pretest(files)
		files.each {|f| cp(build(f),nanoVsOutput) unless uptodate?(nanoVsOutput(f), build(f))}
	end
	_pretest(%w(NMock.dll PicoContainer.dll Castle.DynamicProxy.dll NUnit.Framework.dll NanoContainer.dll NanoContainer.Tests.dll Boo.Lang.CodeDom.dll Boo.Lang.Parser.dll Boo.Lang.Compiler.dll Boo.Lang.dll))
end

task :test => [:compile,:pretest] do
	cd nanoVsOutput
	sh "../../../../lib/nunit-console.exe NanoContainer.Tests.dll"
end