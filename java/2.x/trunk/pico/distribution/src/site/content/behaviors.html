<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
<title>Behaviors</title>

</head>
<body>
<p>Components as managed by PicoContainer can have behaviors added
to them by the container during instantiation.</p>
<h3>Caching</h3>
<p>This is where a component has a single instance in the container
rather that a new one created each time the container is asked for that
type. <a href="http://code.google.com/p/google-guice/">Guice</a> calls
this a Singleton. After guice came out we debated this, and decided that
we should not call this a Singleton. Another PicoContainer instance
could be manging another single instance of the same component, so it
does not fit the definition of Singleton as defined in the Design
Patterns book.</p>
<p>Choose your style for caching behavior:</p>
<div class="source"><pre>
pico = new DefaultPicoContainer(new Caching());
pico.addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre></div>
<div class="source"><pre>
pico = new DefaultPicoContainer();
pico.as(CACHE).addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre></div>
  <div class="source"><pre>pico = new PicoBuilder().withCaching().build();
pico.addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre></div>
  <div class="source"><pre>pico = new PicoBuilder().withBehaviors(caching()).build();
pico.addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre></div>
<h3>Implementation Hiding</h3>
<p>This is where the implementation of the component is hidden from
other components using it. The instance cannot be cast back to the implementation. It only works if the type has an interface
that it implements.</p>

    <div class="source"><pre>
pico = new DefaultPicoContainer(new ImplementationHiding());
pico.addComponent(Apple.class, AppleImpl.class);
Apple a1 = pico.getComponent(Apple.class);
// cannot cast back to AppleImpl
</pre></div>
    <div class="source"><pre>
pico = new DefaultPicoContainer();
pico.as(HIDE).addComponent(Apple.class, AppleImpl.class);
Apple a1 = pico.getComponent(Apple.class);
// cannot cast back to AppleImpl
</pre></div>
    <div class="source"><pre>pico = new PicoBuilder().withImplementationHiding().build();
pico.addComponent(Apple.class, AppleImpl.class);
Apple a1 = pico.getComponent(Apple.class);
// cannot cast back to AppleImpl
</pre></div>
    <div class="source"><pre>pico = new PicoBuilder().withBehaviors(Behaviours.implementationHiding()).build();
pico.addComponent(Apple.class, AppleImpl.class);
Apple a1 = pico.getComponent(Apple.class);
// cannot cast back to AppleImpl
</pre></div>

<p>This Behavior leverages Reflection's dynamic proxy capability.
There's another ImplementationHiding Behavior in Pico Gems that
leverages ASM to make 'more concrete' hidden implementations.</p>
<h3>Thread Safety</h3>
<p>When components are created by two threads concurrently, with the intention of the instance being cached, it is possible in a small percentage of cases for the first instance into the cache to be replaced with a second instance. To prevent this, you may want to try one of two behaviors to make the operation thread safe:</p>
<div class="source">
  <pre>
pico = new DefaultPicoContainer(new Synchronizing().wrap(new Caching()));
pico.addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre>
</div>
<div class="source">
  <pre>
pico = new DefaultPicoContainer();
pico.as(SYNCHRONIZE, CACHE).addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre>
</div>
  <div class="source">
    <pre>pico = new PicoBuilder().withSynchronizing().withCaching().build();
pico.addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre>
  </div>
<div class="source">
  <pre>pico = new PicoBuilder().withBehaviors(synchronizing(), caching()).build();
pico.addComponent(Apple.class);
Apple a1 = pico.getComponent(Apple.class);
Apple a2 = pico.getComponent(Apple.class);
// both the same instance
</pre>
</div>
 <p>The second behavior leverages JDK 1.5's ReentrantLock functionality. To use that, replace SYNCHRONIZE with LOCK, or Syncronizing() with Locking(), withSynchronizing() with withLocking() and synchronizing() with locking() for above code fragments as appicable.</p> 
 <h3>Property Applying</h3>
<p>This is where there are a number of setters for a component that will be could be set after instantiation. A way of handing in some configuration if you like.</p>
<div class="source">
  <pre>
class Foo {
  String message;
  public void setMessage(String message) {
     this.message = message;
  }
  public String toString() {
      return message;
  }
}
...
pico = new DefaultPicoContainer(new PropertyApplying());
pico.addComponent(Foo.class);
PropertyApplicator pa = (PropertyApplicator) pico.getAdapter(Foo.class);
pa.setProperty("message", "hello");
System.out.println(pico.getComponent(Foo.class)); // prints hello
</pre>
</div>
<div class="source">
  <pre>
pico = new DefaultPicoContainer();
pico.as(APPLY_PROPERTIES).addComponent(Foo.class);
PropertyApplicator pa = (PropertyApplicator) pico.getAdapter(Foo.class);
pa.setProperty(&quot;message&quot;, &quot;hello&quot;);
System.out.println(pico.getComponent(Foo.class)); // prints hello
</pre>
</div>
  <div class="source">
    <pre>pico = new PicoBuilder().withProperties().build();
pico.addComponent(Foo.class);
PropertyApplicator pa = (PropertyApplicator) pico.getAdapter(Foo.class);
pa.setProperty(&quot;message&quot;, &quot;hello&quot;);
System.out.println(pico.getComponent(Foo.class)); // prints hello
</pre>
  </div>
  <div class="source">
    <pre>pico = new PicoBuilder().withBehaviors(propertyApplying()).build();
pico.addComponent(Foo.class);
PropertyApplicator pa = (PropertyApplicator) pico.getAdapter(Foo.class);
pa.setProperty(&quot;message&quot;, &quot;hello&quot;);
System.out.println(pico.getComponent(Foo.class)); // prints hello
</pre>
  </div>
  <div class="source">
    <pre>pico = new PicoBuilder().withBehaviors(caching(), propertyApplying()).build();
pico.addComponent(Foo.class);
Cached cached = (Cached) pico.getAdapter(Foo.class);
PropertyApplicator pa = (PropertyApplicator) getDelegate(PropertyApplicator.class);
pa.setProperty(&quot;message&quot;, &quot;hello&quot;);
System.out.println(pico.getComponent(Foo.class)); // prints hello
</pre>
</div>
</body>


</html>
