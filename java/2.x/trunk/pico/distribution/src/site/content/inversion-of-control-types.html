<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Inversion of Control types</title>
</head>
<body>
<div id="container">
  <div id="main">
    <div class="content" style="padding-top: 3mm;">
      <div class="section_2">
        <h2><a name="IoCTypes-Overview" id="IoCTypes-Overview"></a>Overview</h2>
        <p>In recent years different approaches have emerged to deliver an IoC vision.  Latter types, as part of a 'LightWeight' agenda have concentrated on simplicity and transparency. </p>
      </div>
      <div class="section_2">
        <h2><a name="IoCTypes-IoCTypesFamilyTree" id="IoCTypes-IoCTypesFamilyTree"></a>IoC Types - Family Tree</h2>
        <p>Devised in London at the ThoughtWorks office in December of 2003; Present at the &quot;Dependency Injection&quot; meeting were Paul Hammant, Aslak Hellesoy, Jon Tirsen, Rod Johnson (Lead Developer of the Spring Framework), Mike Royle, Stacy Curl, Marcos Tarruela and Martin Fowler (electronically).</p>
        <p><strong>Inversion of Control</strong></p>
        <ul>
          <li>Dependency Injection (former type 3)
            <ul>
              <li>Constructor Dependency Injection (CDI) <br />
                <br/>
                Examples: PicoContainer, Spring Framework, (not in EJB 3.x sadly), Guice with Annotations </li>
              <li>Setter Dependency Injection (former type 2)<br />
                <br/>
                Examples: Spring Framework, PicoContainer, EJB 3.0 &amp; Guice with Annotations </li>
              <li>Interface Driven Setter Dependency Injection<br />
                <br/>
                Examples: XWork, WebWork 2</li>
              <li>Field Dependency Injection<br />
                <br/>
                Examples: Plexus, PicoContainer &amp; Guice with Annotations. </li>
            </ul>
          </li>
          <li>Dependency Lookup
            <ul>
              <li>Pull approach (registry concept)<br />
                <br/>
                Examples: EJB 2.x that leverages JNDI, Servlets that leverage JNDI</li>
              <li>Contextualized Dependency Lookup (former type 1) AKA Push approach <br />
                <br/>
                Examples: Servlets that leverage ServletContext, Apache's Avalon, OSGi, Keel, Loom (they use Avalon)</li>
            </ul>
          </li>
        </ul>
        <p>See also <a href="constructor-injection.html" title="Constructor Injection">Constructor Injection</a>, <a href="setter-injection.html" title="Setter Injection">Setter Injection</a>, <a href="contextualized-lookup.html" title="Contextualized Lookup">Contextualized Lookup</a> for more information.</p>
        <p>Note Field Injection was provisionally known as 'type 4'. There was really no interest 'type 4' until EJB3.0. Getter Injection flourished for a while, but did not take and was never supported by the PicoContainer team.</p>
      </div>
      <div class="section_2">
        <h2><a name="IoCTypes-ExamplesofCommonTypes" id="IoCTypes-ExamplesofCommonTypes"></a>Examples of Common Types</h2>
        <div class="section_3">
          <h3><a name="IoCTypes-ConstructorDependencyInjection" id="IoCTypes-ConstructorDependencyInjection"></a>Constructor Dependency Injection</h3>
          <p>This is where a dependency is handed into a component via its constructor :</p>
          <div class="code">
            <div class="codeContent">
              <pre class="code-java">public interface Orange {
  // methods
}

public class AppleImpl implements Apple {
  private Orange orange;
  public AppleImpl(Orange orange) {
    this.orange = orange;
  }
  // other methods
}</pre>
            </div>
          </div>
        </div>
        <div class="section_3">
          <h3><a name="IoCTypes-SetterDependencyInjection" id="IoCTypes-SetterDependencyInjection"></a>Setter Dependency Injection</h3>
          <p>This is where dependencies are injected into a component via setters :</p>
          <div class="code">
            <div class="codeContent">
              <pre class="code-java">public interface Orange {
  // methods
}

public class AppleImpl implements Apple {
  private Orange orange;
  public void setOrange(Orange orange) {
    this.orange = orange;
  }
  // other methods
}</pre>
            </div>
          </div>
        </div>
        <div class="section_3">
          <h3><a name="IoCTypes-ContextualizedDependencyLookup%28PushApproach%29" id="IoCTypes-ContextualizedDependencyLookup%28PushApproach%29"></a>Contextualized Dependency Lookup (Push Approach)</h3>
          <p>This is where dependencies are looked up from a container that is managing the component :</p>
          <div class="code">
            <div class="codeContent">
              <pre class="code-java">public interface Orange {
  // methods
}

public class AppleImpl implements Apple, DependencyProvision {
  private Orange orange;
  public void doDependencyLookup(DependencyProvider dp) throws DependencyLookupExcpetion{
    this.orange = (Orange) dp.lookup(&quot;Orange&quot;);
  }
  // other methods
}</pre>
            </div>
          </div>
        </div>
      </div>
      <div class="section_2">
        <h2><a name="IoCTypes-Terms%3AService%2CComponent%26Class" id="IoCTypes-Terms%3AService%2CComponent%26Class"></a>Terms: Service, Component &amp; Class</h2>
        <p>Component is the correct name for things managed in an IoC sense.  However very small ordinary classes are manageable using IoC tricks, though this is for the very brave or extremists <img class="emoticon" src="http://docs.codehaus.org/images/icons/emoticons/smile.gif" height="20" width="20" align="absmiddle" alt="" border="0" /></p>
        <p>A component many have dependencies on others.  Thus dependency is the term we prefer to describe the needs of a component.</p>
        <p>Service as a term is very popular presently. We think 'Service' dictates marshaling and remoteness. Think of Web Service, Database service, Mail service. All of these have a concept of adaptation and transport.  Typically a language neutral  form for a request is passed over the wire.  In the case of the Web Service method requests are marshaled to SOAP XML and forward to a suitable HTTP server for processing.  Most of the time an application coder is hidden from the client/server and marshaling ugliness by a toolkit or API.</p>
      </div>
      <div class="section_2">
        <h2><a name="IoCTypes-ObsoletedTerms" id="IoCTypes-ObsoletedTerms"></a>Obsoleted Terms</h2>
        <p>Types 1, 2 and 3 IoC were unilaterally coined earlier in 2003 by the PicoContainer team and even <a href="http://java.sys-con.com/read/38102.htm">published</a>, before Dependency Injection rightly took over. </p>
        <p>Type 1 becomes Contextualized Dependency Lookup<br />
          <br/>
          Type 2 becomes Setter Dependency Injection<br />
          <br/>
          Type 3 becomes Constructor Dependency Injection</p>
      </div>
      <div class="section_2">
        <h2><a name="IoCTypes-DependencyInjectionversusContextualizedLookup" id="IoCTypes-DependencyInjectionversusContextualizedLookup"></a>Dependency Injection versus Contextualized Lookup</h2>
        <p>Dependency Injection is non-invasive.  Typically this means that components can be used without a container or a framework. If you ignore life cycle, there is no import requirements from an applicable framework.</p>
        <p>Contextualized Dependency Lookup is invasive.  Typically this means components must be used inside a container or with a framework, and requires the component coder to import classes from the applicable framework jar.</p>
        <p>Note that Apache's Avalon (and all former type-1 designs) are not Dependency Injection at all, they are Contextualized  Dependency Lookup.</p>
        <p>Ultimately, the contextualized lookup designs are not recommended at all. </p>
      </div>
      <div class="section_2">
        <h2><a name="IoCTypes-What%27swrongwithJNDI%3F" id="IoCTypes-What%27swrongwithJNDI%3F"></a>What's wrong with JNDI ?</h2>
        <p>With plain JNDI, lookup can be done in a classes' static initialiser, in the constuctor or any method including the finaliser.  Thus there is no control (refer C of IoC). With JNDI used under EJB control, and concerning only components looked up from that bean's sisters (implicitly under the same container's control), the specification indicates that the JNDI lookup should only happen at a certain moment in the startup of an EJB application, and only from a set of beans declared in ejb-jar.xml.  Hence, for EJB containers, the control element should be back.  Should, of course, means that many bean containers have no clue as to when lookups are actually being done, and apps work by accident of deployment.  Allowing it for static is truly evil. It means that a container could merely be looking at classes with reflection in some early setup state, and the bean could be going off and availing of remote and local services and components.  Thus depending whether JNDI is being used in an Enterprise Java Bean or in a POJO, it is either an example of IoC or not.</p>
      </div>
   </div>
   </div>
   </div>
</body>
</html>
