<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
<title>Scopes</title>
</head>
<body>
<p>PicoContainer's scope hinges on parent/child container
relationships. From a PicoContainer instance you can make a child
container via makeChildContainer() or addChildContainer(..).</p>
<p>These hierarchies of container can be set up with parents and
children refering to each other, or children referring to parents only,
or parents referring to children only. This changes the way that things
work considerably. If a child has its parent registered, then it can
lean on it for component resolution (but not without). If a parent has
its child registered asa child, then it can manage it (start, stop,
dispose cascade into children).</p>
<p>Web frameworks leveraging PicoContainer typically setup child up
with parent containers, but grant no visibility of the child to the
parent. This is so that containers can be garbage collected at the end
of their scope.</p>
<h2>Simple Examples</h2>
<p>Here are examples of parent/child setup:</p>
    <div class="source">
      <pre>
parent = new DefaultPicoContainer();
parent.addComponent(Apple.class);
parent.addComponent(Orange.class);
parent.addComponent(Pear.class);
child = parent.makeChildContainer();
child.addComponent(DependsOnApple.class);
// this is OK
parent.start();
// cascades to child just fine
</pre>
</div>
<div class="source">
  <pre>
parent = new DefaultPicoContainer();
parent.addComponent(Apple.class);
parent.addComponent(Orange.class);
parent.addComponent(Pear.class);
child = parent.addChildContainer(new DefaultPicoContainer());
child.addComponent(DependsOnApple.class);
// this is NOT OK. child can't see parent
parent.start();
// cascades to child just fine
</pre>
</div>
<div class="source">
  <pre>
parent = new DefaultPicoContainer();
parent.addComponent(Apple.class).addComponent(Orange.class).addComponent(Pear.class);
child = parent.addChildContainer(new DefaultPicoContainer(parent));
child.addComponent(DependsOnApple.class);
// this is OK
parent.start();
// cascades to child just fine
</pre>
</div>
<div class="source"><pre>parent = new DefaultPicoContainer();
parent.addComponent(Apple.class).addComponent(Orange.class).addComponent(Pear.class);
child = new DefaultPicoContainer(parent);
child.addComponent(DependsOnApple.class);
// this is  OK
parent.start();
// does NOT cascades to child 
</pre>
</div>
<p>There is no limit to the extent of the chained containers.
Grandparent, Parent, Grandchild (etc) is OK.</p>
<p>Garbage collection is a good way of disposing of scoped containers. If the children refer to the parents, then assign child to null just works. If the parents refer to the children too, then you'll have to do a removeChildContainer first before it will be eligible for garbage collection.</p>
<h2>Web Containers / Web Frameworks</h2>
<p>There are only about a million for the Java servlet container. There more recent and sophisticated ones try to do Dependency Injection for 'actions' or 'controllers'. If you want to use PicoContainer for a web framework, then you're likely to end up with three container levels. The root container would be common to all and known as the application-level container. One level further would be a session-level one, with the app one marked as its parent. One level further would be a request level one, with the session on marked as its parent. There are two not so subtle varations on how they would be used. One, we poineered with PicoContainer 1.x in 2003, the other inroduced with PicoContainer 2.x in 2007.</p>
<h3>PicoContainer and web frameworks - the old way.</h3>
<p>You make one instance of the app container. For each new HTTP Session you make a new session level container, and put it into the session itself - refer HttpSession.setAttribute(key,val). For each request, you make a new Request level container and discard it at the end of the request. For as long as it lives, the request level container's parent would be the session container.</p>
<p>There are two downsides of this approach. 1) you have to repeatedly add components to the session and request containers as they are instantiated. 2) the serialization of the session (by Tomcat etc) might cause more things to be serialized than you intend - i.e. the session container refers to the application container.</p>
<h3>PicoContainer and web frameworks - the new way.</h3>
<p>You make one instance of the app, session and request container on servlet load. For the Application one, you choose Caching as the behavior factory. For the session and request level ones, you choose Storing instead. You wrap the Storing behavior factory instances in HttpSessionStoring and reprogram each http request like so:</p>
<div class="source">
  <pre>
public class MyTinyPicoServlet extends HttpServlet {

    private DefaultPicoContainer requestContainer;

    private HttpSessionStoring sessionStoring;
    private HttpSessionStoring requestStoring;

    public void init(ServletConfig cfg) throws ServletException {

        PicoContainer appContainer = new DefaultPicoContainer(new Caching());

        Storing sessionStore = new Storing();

        PicoContainer sessionContainer = new DefaultPicoContainer(sessionStore, appContainer);

        sessionStoring = new HttpSessionStoring(sessionStore, &quot;sessionStore&quot;);

        Storing requestStore = new Storing();
        requestContainer = new DefaultPicoContainer(requestStore, sessionContainer);
        requestStoring = new HttpSessionStoring(requestStore, &quot;requestStore&quot;);

        // populate app, session and request scoped containers.
        // appContainer.addComponent(HibernateManager.class, MyHibernateManager.class); // all users/people share one HibernateManager
        // sessionContainer.addComponent(ShoppingCart.class, FifoCart.class); // a new cart per person
        // requestContainer.addComponent(&quot;/addToCart.do&quot;, AddToCart.class);
        // requestContainer.addComponent(&quot;/removeFromCart.do&quot;, RemoveFromCart.class);
        // etc

    }

    protected void service(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {

        sessionStoring.retrieveStoreFromHttpSession(req);
        requestStoring.flushStore();

        Action action = (Action) requestContainer.getComponent(req.getPathTranslated());

        action.execute(req, resp); // yeah yeah, this is pretty basic

        sessionStoring.putStoreInHttpSession(req);

        sessionStoring.invalidateStore();
        requestStoring.invalidateStore();
        // trying to retrieve components from at session or request scopes here will result in an UnsupportedOperationException
    }

}
</pre>
</div>
<p>HttpSessionStoring is not in the core jar, its in the 'gems' one.</p>
</body>
</html>
