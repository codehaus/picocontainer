<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
</head>
<body>
<h1>Lifecycle</h1>
<h2>Simple lifecycle</h2>

<p>[Explain that for the simplest possible thing you should consider
not using a lifecycle]</p>

<h2>Custom lifecycles</h2>

<p>Custom lifecycle management is a common requirement for components.
Probably because it is so crucial there are many competing implementations, and
each has its own passionate group of advocates.</p>

<p>Pico tries to avoid controversy by being completely agnostic about the
lifecycle/lifecycles that it supports. Pico does have an implementation
of a simple lifecycle (see org.picocontainer.lifecycle) but this is there
only as a convenience.</p>

<p>Instead of mandating a single restrictive lifecycle, Pico provides
hooks that allow you to plug in almost any concievable lifecycle (or
for that matter any other 'aggregated' behaviour).</p>

<h2>The AggregateProxy</h2>

<p>Say you have an interface:</p>

<pre>
    public interface Peelable {
        void peel();
    }</pre>

<p>If you have a container that is full of objects that are Peelable:</p>

<pre>
    pico.registerComponent(Apple.class);
    pico.registerComponent(Pear.class);
    pico.registerComponent(Grape.class);
    pico.registerComponent(Orange.class);
    pico.registerComponent(Potato.class);</pre>

<p>It would be useful to just tell the container to <pre>peel()</pre> them all
for you:</p>

<pre>
    pico.peel();</pre>

<p>What you would like to do here is treat the whole
container like a Peelable, so that when you call peel() on the
container it calls peel() on all the individual components for you.</p>

<p>Pico <b>does</b> let you do this:</p>

<pre>
    Object proxy = pico.getAggregateComponentProxy();

    Peelable peelable = (Peelable) proxy;
    peelable.peel();</pre>

<p>In fact Pico gives you even more than that, because the Object that
getAggregateComponentProxy() returns <b>implements all the interfaces that your
components implement</b>.</p>

<p>What this means is that if one of your components (say Potato.class)
implements a different interface (say Mashable) then you can call that
interface in the same way:</p>

<pre>
    Mashable mashable = (Mashable) proxy;

    mashable.mash();</pre>

<p>Of course the mash() method is only applied to any components that
implement the interface Mashable. So you can't accidentally mash() an
Apple or an Orange.</p>

<h2>Advantages of the AggregateProxy</h2>

<p>Totally decoupled lifecycle methods are possible, because Pico will
generate a proxy for <b>any</b> interface even if it is in a package
that Pico knows nothing about.</p>

<p>Competing / complementary lifecycle patterns can be implemented without
comprimising Pico's simplicity. In fact Pico can support multiple
lifecycle implementations at the same time.</p>

<p>Interface methods can throw Exceptions that are checked and domain
specific. Again, Pico doesn't need to know.</p>

<p>Interfaces are strongly typed, not breakable as in reflection.</p>

</body>
</html>
