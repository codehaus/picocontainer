<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Configuration</title>
</head>
<body>
<h2>Overview</h2>
Configuration for PicoContainer components requires some
explanation.&nbsp; The basic idea is that a component should <span
 style="font-weight: bold;">not</span> be tied to a single
configuration design.<br>
<br>
There are two ways a developer may declare configuration needs for a
component.&nbsp; The first is as seperate parameters in the
constructor, the second is as a bespoke configuration
pseudo-component, also passed in through constructor.<br>
<h2>Constructor parameters</h2>
Consider a component a that requires configuration :<br>
<pre>&nbsp;&nbsp;&nbsp; class Foo {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Foo(DependantComp dComp, String fooName, Integer barNumber) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</pre>
Clearly the string and the integer are not components.&nbsp; What we
need is a way
of passing in those parameters at runtime. Possibily interleaved with
real components.<br>
<pre>&nbsp;&nbsp;&nbsp; MutablePicoContainer pico = new DefaultPicoContainer();<br>&nbsp;&nbsp;&nbsp; pico.registerComponent(DefaultDependantComp.class);<br>&nbsp;&nbsp;&nbsp; pico.registerComponent(Foo.class);<br>&nbsp;&nbsp;&nbsp; pico.addParameterToComponent(Foo.class, String.class, "foo");<br>&nbsp;&nbsp;&nbsp; pico.addParameterToComponent(Foo.class, Integer.class, new Integer(33);<br>&nbsp;&nbsp;&nbsp; pico.start();</pre>
<br>
Obviously you'd have some soft coded implementation rather than that
hard coded above.&nbsp; We're trying to illustrate the intermingling of
components and configuration.&nbsp; Well perhaps we are if you consider
the following component :<br>
<br>
<pre>&nbsp;&nbsp;&nbsp; class Foo {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Foo(Wilma wilma, String fooName, FredImpl fred, Integer barNumber) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>    ....<br>
&nbsp;&nbsp;&nbsp; PicoContainer pico = new HierarchicalPicoContainer.Default();
&nbsp;&nbsp;&nbsp; pico.registerComponent(Foo.class);
&nbsp;&nbsp;&nbsp; pico.registerComponent(Wilma.class, WilmaImpl.class);<br><br>&nbsp;&nbsp;&nbsp; pico.registerComponent(FredImpl.class);<br><br>&nbsp;&nbsp;&nbsp; pico.addParameterToComponent(Foo.class, String.class, "foo");<br>&nbsp;&nbsp;&nbsp; pico.addParameterToComponent(Foo.class, Integer.class, new Integer(33);<br>&nbsp;&nbsp;&nbsp; pico.start();</pre>
<h2>Pseudo-component<br>
</h2>
<pre>&nbsp;&nbsp;&nbsp; class Foo {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Foo(DependantComp dComp, FooConfig fooConfig) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br><br>&nbsp;&nbsp;&nbsp; interface FooConfig {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String getFooName();<br>      int getBarNumber(); // note this is int not Integer (restriction lifted).<br>&nbsp;&nbsp;&nbsp; }<br></pre>
<pre>Without going into the how, many implementations of the FooConfig are possible.<br></pre>
<pre>&nbsp;&nbsp;&nbsp; MutablePicoContainer pico = new DefaultPicoContainer();<br>&nbsp;&nbsp;&nbsp; pico.registerComponent(DefaultDependantComp.class);<br>&nbsp;&nbsp;&nbsp; pico.registerComponent(Foo.class);<br>&nbsp;&nbsp;&nbsp; pico.registerComponent( DefaultFooConfig.class );<br>&nbsp;&nbsp;&nbsp; //pico.registerComponent( DefaultFooConfig.class );<br>&nbsp;&nbsp;&nbsp; //pico.registerComponent( PropertiesFileFooConfig.class );<br>&nbsp;&nbsp;&nbsp; //pico.registerComponent( XmlFileFooConfig.class );<br>&nbsp;&nbsp;&nbsp; //pico.registerComponent( ParallelUniverseFooConfig.class );<br>&nbsp;&nbsp;&nbsp; //pico.registerComponent( WebPageReadingFooConfig.class );<br>&nbsp;&nbsp;&nbsp; //pico.registerComponent( FromTibcoFooConfig.class );<br>    //pico.registerComponentImplementation ( myAvalonConfigurableForLegacySupportFooConfig );&nbsp;&nbsp;&nbsp; <br>    //pico.registerComponentImplementation ( someCarefullyDeserializedFooConfig );&nbsp;&nbsp;&nbsp; <br>    pico.start();</pre>
Clearly a person needs to write an adaptor, but <span
 style="font-weight: bold;">any</span> adaptor can be written. The
developer who uses the component can do anything - they are not forced
to fit one configuration design.<br>
<h2>Anti-patterns</h2>
In non IoC designs, a component may hard code its configuration in one
of a number of ways....<br>
<br>
True hard coding:<br>
<pre>&nbsp;&nbsp;&nbsp; class MyWebServer {<br>      ServerSocket socket;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public MyWebServer() {<br>      }<br>      public void start() {<br>        // listen on port 80<br>        socker = new ServerSocket(80); <br>      }<br>&nbsp;&nbsp;&nbsp; }<br></pre>
Bound to a specific properties file:<br>
<pre>&nbsp;&nbsp;&nbsp; class MyWebServer {<br>      ServerSocket socket;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public MyWebServer() {<br>      }<br>      public void start() {<br>        ResourceBundle rb = new ResourceBundle("MyWebServer.properties");<br>        socker = new ServerSocket(rb.getIntProperty("port.number"); <br>      }<br>&nbsp;&nbsp;&nbsp; }<br></pre>
There are IoC anti-patterns as the embedor can't choose their own
configuration mechanism. An application comprising a number of
components may have to include multiple xml and properties files to
control the configuration. <br>
<br>
<small>Authors: Paul Hammant</small><br>
<br>
</body>
</html>
