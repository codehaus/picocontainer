<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Differentiators</title>
</head>
<body>
Pico components (to remind you) are simple java classes that declare
their dependencies in the constructor(s). No meta XML for dependencies.
No framework classes/interfaces to extend/implement.<br>
<br>
There are a number of specifications from the last few years that
proport to be container/component designs...<br>
<h3>Sun specified nearly-IoC Containers &amp; Component designs</h3>
It could be said that Sun have created a few container/component
designs.......<br>
<h4>Enterprise Java Beans<br>
</h4>
Clearly Entity and Session beans run inside a container.&nbsp; The API
is well defined, and to varying degrees of success one can deploy EJB
appllications to WebLogic, WebSphere, Orion and JBoss etc.&nbsp;
For assembly and configuration, there is high use of element-normal XML
. There
are some mandated
parent objects and interfaces for various to extend and/or implement.
Resolution is done by the components themselves via JNDI more often
than not.<br>
<br>
PicoComponents are simpler in they they do not force an extensive XML
markup, nor require the implementing of certaing interfaces or extening
base classes. Quite importantly the relationship between factory
(home), implementation (bean) and interface (remote) parts is much more
real in PicoComponents. Lastly, EJB components are nearly impossible to
unit-test without much effort.<br>
<h4>Servlets</h4>
Not so obvious - Servlets are contained by a servlet container. They
are generally bundled with (or replaced by) value added propositions
like JSP, but it is still a container/component design.&nbsp;&nbsp;
High use of XML for assembly and configuration.&nbsp; Servlets have no
concept of parent container or the conatainer above that (sometimes
EJB) and&nbsp; its provision of components, which is very unfortunate.
Servlets have a number of interfaces to honor, none of which is too
malignent. Servlets typically deal with external (or parent) components
via RMI or JNDI.&nbsp; In more recent releases of EJB, local interfaces
rather than RMI may be the mechanism for connection the parent
components.&nbsp; WebLogic have always provided an optimizing mechanism
for this interoperation<br>
<br>
As with EJB, PicoComponents are far simpler.&nbsp; This is probably
because they offer no web experience, apart from anything else.
Servlets again are not that unit-testable.<br>
<h4>Applets</h4>
Applets, though presently not so often used, are a good
example of Container/Component separations.&nbsp; There is very little
XML in use by Applets.&nbsp; Configuration is typically delivered in
applet tags in HTML. Applets are granted some access to the parent
container, the brower, and&nbsp; its DOM model for pages and other
applets.&nbsp; There very little standardisation for Browser as a
container.<br>
<br>
As with EJB, PicoComponents are far simpler.&nbsp; Applets are
unit-testable but with a little effort. Complex DOM interoperation is
impossible under unit testing.<br>
<h3>Non IoC container-like things by various<br>
</h3>
<h4>Mainable (Sun)<br>
</h4>
"public static void main(String[] args) {}"&nbsp; Familiar?
Hopefully not :-) Static plays no part in a good IoC
container/component design. This includes static launching of Java
Webstart (JNLP)
applications.&nbsp; If you have to keep mainable functionaility
separate your components away from the main() class so they may be
instntiated separately. In .NET you'll have to make sure that the
application assembly is a small bootstrap to a component one.<br>
<h4>Singleton (pattern) </h4>
The singleton pattern was detailed in the "Design Patterns" book.&nbsp;
Because of its static nature and public availability, it allows
component writers to obscurely reference other components.&nbsp;
Overuse makes for bad solutions.&nbsp; In a
IoC design we would replace this with a container managed single
instance.<br>
<h4>Static Factory (pattern) </h4>
Used in a similar way the Singleton pattern (and similarly detailed in
"Design Patterns"), this allows disparate classes to create/get other
components.&nbsp; Very dirty applications result from overuse of static
factories<br>
<h4>JNDI ( Java API )<br>
</h4>
A huge map of clunkily access components via a very non-IoC mechanism.
It has to be strapped with much XML to prevent inappropriate
access.&nbsp; This is not IoC because the component reaches out for
external component dependancies whenever it feels like.&nbsp; This last
fact clouds Serlvets and EJB use.<span style="font-weight: bold;"><br>
</span>
<h4><span style="font-weight: bold;"></span>AWT, Swing, SWT ( Java gfx
toolkits)<br>
</h4>
Nice container/component designs. In the case of Swing, perhaps a
little difficult for coders to easily assemble applications. <br>
<h4>Eclipse (Java grapical application platform)</h4>
The Eclipse platform is very compelling.&nbsp; It supports the notion
of a pluggable application concept. Each component statically accesses
other components via a factory (which at least Paul does not like),
though it is clear that some complex classloader magic is going
on.&nbsp; The underpinning set of graphical components, SWT ,&nbsp; are
a simple and elegant design.<br>
<h3>Other IoC container / component designs</h3>
<h4>Avalon-Framework and its containers</h4>
Apache hosts a project that has been running for years called Avalon.
It has many components that fit that its design and many
containers is writtern in Java, with a port underway to C#.&nbsp;
Avalon components are characterised by implementation of many optional
interfaces. Avalon components are distributed with meta-information in
XML in the jar file.&nbsp; More XML is required to assemble components
together for the same of a application. Avalon-Phoenix, Excalibur
Component Manager (ECM), Avalon-Fortress and Avalon-Merlin are the
pertinent containers .<br>
<br>
Apache-Avalon requires implementing components to implement a number of
interfaces. This has proven historically to be a bit of a turn-off for
component writers. Luckily there are no abstract classes that have to
be extended by component writers.&nbsp; Those interfaces are :-<br>
<br>
<table cellpadding="2" cellspacing="2" border="0"
 style="text-align: left; width: 60%;">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Avalon
Interface<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">PicoContainer
equivalent<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">LogEnabled</td>
      <td style="vertical-align: top;">Logging agnostic<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Contextualizable</td>
      <td style="vertical-align: top;">n/a</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Serviceable (used to be called
Composable) </td>
      <td style="vertical-align: top;">Arguments in Constructor<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Configurable</td>
      <td style="vertical-align: top;">Arguments in Constructor<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Parameterizable</td>
      <td style="vertical-align: top;">n/a</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Initializable</td>
      <td style="vertical-align: top;">Constructor is eqivalent
lifecycle place.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Startable</td>
      <td style="vertical-align: top;">Startable &amp; Stoppable<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Suspendable</td>
      <td style="vertical-align: top;">n/a</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Recontextualizable</td>
      <td style="vertical-align: top;">n/a</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Recomposable</td>
      <td style="vertical-align: top;">n/a</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Reconfigurable</td>
      <td style="vertical-align: top;">n/a</td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Reparameterizable</td>
      <td style="vertical-align: top;">n/a<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Disposable</td>
      <td style="vertical-align: top;">Disposable</td>
    </tr>
  </tbody>
</table>
<br>
Avalon is a type-1 IoC design. Its flaw is that components written for
it cannot be used without an Avalon-Framework compatible container.
Many say that the XML that has to accompany each component is also a
flaw.&nbsp; Unit-testing of Avalon components is very difficult because
it is difficult to manage the components from JUnit.<br>
<h4>Carbon </h4>
todo<br>
<br>
</body>
</html>
