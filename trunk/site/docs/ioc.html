<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Inversion of Control</title>
</head>
<body>
<h2>Overview</h2>
<br>
Inversion of Control (IoC) is a design pattern that addresses a
component's <a href="#dependencies"><span style="font-weight: bold;">dependencies</span></a>,
<span style="font-weight: bold;"><a href="#configuration">configuration</a>
</span>and <a href="#lifecycle"><span style="font-weight: bold;">lifecycle</span></a>.
Note to confuse things slightly, IoC is also relevant to simple
classes, not just components, but we will refer to components
throughout this text.&nbsp; There are many <a href="types-of-ioc.html">types
of IoC</a>, but we'll concentrate on the type of IoC that PicoContainer
introduced to the community.&nbsp; Formerly known as type-3, now known
as Constructor Injector.<br>
<h3>IoC synonyms <br>
</h3>
Another well-known synonym for IoC is <span style="font-weight: bold;">Dependency
Inversion
Principle</span> (DIP). This is described in an excellent paper written
by Robert
C. Martin: <a
 href="http://www.objectmentor.com/resources/articles/dip.pdf">dip.pdf</a>&nbsp;
A third nickname for IoC is <span style="font-weight: bold;">The
Hollywood
Principle</span> (Don't call us we'll call you).<br>
<h2><a name="dependencies"></a>Component Dependencies<br>
</h2>
It generally favors loose coupling between components. Loose coupling
in turn favours:<br>
<ul>
  <li>More reusable classes<br>
  </li>
  <li>Classes that are easier to test</li>
  <li>Systems that are easier to assemble and configure</li>
</ul>
<h3>Explanation</h3>
Simply put, a component designed
according to IoC does not go off and get other components that
it needs in order to do its job. It instead declares them to its
container,
and
the container supplies them. Thus the name IoC/DIP/Hollywood Principle.
The
control of the dependencies for a given component is <span
 style="font-style: italic;">inverted</span>. It is no longer the
component
itself that establishes its own dependencies, but <span
 style="font-style: italic;">something</span> on the
outside. That something could be a formal container like PicoContainer,
but could easily be normal code instantiating the component in an
embedded sense.<br>
<h3>Examples</h3>
Here is the simplest possible IoC component :<br>
<pre style="margin-left: 40px;">public interface Orange {<br>&nbsp; // methods<br>}<br><br>public class AppleImpl implements Apple {<br>&nbsp; private Orange orange;<br>&nbsp; public AppleImpl(Orange orange) {<br>&nbsp;&nbsp;&nbsp; this.orange = orange;<br>&nbsp; }<br>&nbsp; // other methods<br>}</pre>
Here are some common smells that should lead you to refactor to IoC :<br>
<pre style="margin-left: 40px;">public class AppleImpl implements Apple{<br>&nbsp; private Orange orange;<br>&nbsp; public Apple() {<br>&nbsp;&nbsp;&nbsp; this.orange = new OrangeImpl();<br>&nbsp; }<br>&nbsp; // other methods<br>}</pre>
<br>
The problem is that you are tied to the OrangleImpl <em>implementation</em>
for provision of Orange
<em>services</em>. Simply put, the above apple cannot be a
(configurable) component. It's an
application. All hard coded. Not reusable. It is going to be very
difficult to have multiple instances in the same classloader with
different assembly.<br>
<br>
Here are some other smells along the same line :<br>
<pre style="margin-left: 40px;">public class AppleImpl implements Apple {<br>  private static Orange orange = OrangeFactory.getOrange();<br>&nbsp; public Apple() {<br>&nbsp; }<br>&nbsp; // other methods<br>}</pre>
<h3><a name="configuration"></a>Component Configuration</h3>
Sometimes we see configuration like so ...<br>
<pre style="margin-left: 40px;">public class BigFatComponent {<br>&nbsp;&nbsp;String config01;<br>&nbsp;&nbsp;String config02;<br>&nbsp;&nbsp;public BigFatComponent() {<br>&nbsp;&nbsp;&nbsp;&nbsp;ResourceFactory resources = new ResourceFactory(new File("mycomp.properties"));<br>&nbsp;&nbsp;&nbsp;&nbsp;config01 = resources.get("config01");<br>&nbsp;&nbsp;&nbsp;&nbsp;config02 = resources.get("config02");<br>&nbsp;&nbsp;}<br>&nbsp; // other methods<br>}</pre>
In the IoC world, it might be better to see the following for simple
component designs :<br>
<pre style="margin-left: 40px;">public class BigFatComponent {<br>&nbsp;&nbsp;String config01;<br>  String config02;<br>&nbsp;&nbsp;public BigFatComponent(String config01, String config02) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.config01 = config01;<br>&nbsp;&nbsp;&nbsp;&nbsp;this.config02 = config02;<br>&nbsp;&nbsp;}<br>&nbsp; // other methods<br>}</pre>
Or this for more complex ones, or ones designed to be more open to
reimplementation&nbsp; ..<br>
<pre style="margin-left: 40px;">public interface BigFatComponentConfig {<br>&nbsp;&nbsp;String getConfig01();<br>&nbsp;&nbsp;String getConfig02();<br>}<br><br>public class BigFatComponent {<br>&nbsp;&nbsp;String config01;<br>&nbsp;&nbsp;String config02;<br>&nbsp;&nbsp;public BigFatComponent(BigFatComponentConfig config) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.config01 = config.getConfig01();<br>&nbsp;&nbsp;&nbsp;&nbsp;this.config02 = config.getConfig02();<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;// other methods<br>}</pre>
With the latter design there could be many different implementations of
BigFatComponentConfig. Implementations such as:<br>
<ul>
  <li>Hard coded (a default impl)</li>
  <li>Implementations that take config from an XML document (file, URL
based or inlined in
using class)</li>
  <li>Properties File.</li>
</ul>
It is the deployer's, embeddor's or container maker's choice on which
to use.<br>
<h2><a name="lifecycle"></a>Component Lifecycle</h2>
Simply put, the lifecycle of a component is what happens to it in a
controlled sense after it has been instantiated.&nbsp; Say a component
has to start threads, do some timed activity or listen on a socket. The
component, if not IoC, might do its start in its contructor. Better
would be to honor some start/stop functionality from an interface, and
have the container or embeddor manage the starting and stopping when
they feel it is appropriate:<br>
<pre style="margin-left: 40px;">public class SomeDaemonComponent implements Startable {<br>  public void start() {<br>    // listen or whatever<br>  }<br>  public void stop() {<br>  }<br>&nbsp; // other methods<br>}<br><br></pre>
<h3>Notes </h3>
<br>
The lifecycle interfaces for PicoContainer are the only characterising
API elements for a component. If Startable was in the JDK, there would
be no need for this.&nbsp; Sadly, it also menas that every framework
team has to write their own Startable interface.&nbsp; <br>
<br>
The vast majority of components do not require lifecycle functionality,
and thus don't have to implement anything.<br>
<h2>IoC Exceptions</h2>
Of course, in all of these discussions, it is important to point out
that logging is a common exception to the IoC rule. Apache has two
static logging frameworks that are in common use: Commons-Logging and
Log4J. Neither of these is designed along IoC lines.&nbsp; Their
typical use is static accessed whenever it is felt appropriate in an
application.<br>
<br>
<small>Authors: Paul Hammant</small><br>
</body>
</html>
